#lang ivy1.7

include basic

type msg_type_t = { req_read_not_share_dirty_t,
                        req_read_no_snp_t,
                        req_read_unique_t,
                        data_todo_t,
                        snp_read_not_share_dirty_fwd_t
                    }

module msg_t = {
    individual in_use: bool

    individual src_id: nid_t
    individual tgt_id: nid_t
    individual txn_id: txn_idx_t
    individual addr: addr_t
    individual opcode: msg_type_t
    individual dbid: txn_idx_t
    individual return_nid: nid_t
    individual return_txn_id: txn_idx_t
    individual home_nid: nid_t
    individual data: data_t
    # TODO: replace to resp
    individual share: bool
    individual fwd_nid: nid_t

    after init {
        in_use := false
    }
}

instance msg(I: midx_t): msg_t

relation msg_le(X: midx_t, Y: midx_t)
# invariant msg_le(X, Y) & msg_le(Y, Z) -> msg_le(X, Z)
# invariant msg_le(X, Y) & msg_le(Y, X) -> X = Y
# invariant msg_le(X, Y) -> msg_le(X, X) & msg_le(Y, Y)
# invariant msg_le(X, X) & msg_le(Y, Y) -> msg_le(X, Y) | msg_le(Y, X)
# invariant msg(X).in_use <-> msg_le(X, X)

after init {
    msg_le(X, Y) := false;
}

action msg_new returns(msg_r: midx_t) = {
    assume ~msg(msg_r).in_use;
    msg(msg_r).in_use := true;
    assert ~msg_le(msg_r, msg_r);
    msg_le(msg_r, msg_r) := true;
    msg_le(msg_r, X) := msg_le(X, X);
}

action msg_free(f: midx_t) = {
    assert msg(f).in_use & msg_le(f, f);
    msg(f).in_use := false;
    msg_le(X, f) := false;
    msg_le(f, X) := false;
}
