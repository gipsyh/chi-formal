#lang ivy1.7

include basic
include message

module txn_slot_t = {
    individual in_use: bool
    individual addr: addr_t
    individual wait: bool
    individual wake: txn_idx_t
    individual msg: midx_t

    after init {
        in_use := false;
    }

    action default = {
        wait := true;
        wake := txn_idx_null;
    }
}

module channel_t = {
    var head: nat_idx_t
    var tail: nat_idx_t
    individual map(I: nat_idx_t): midx_t

    after init {
        head := 0;
        tail := 0;
    }

    action send returns(res: midx_t) = {
        map(head) := msg_new;
        res := map(head);
        head := head + 1;
    }

    action recv returns (res: midx_t) = {
        assume head > tail;
        res := map(tail);
        tail := tail + 1;
    }
}

module node_t = {
    individual cache_state(A: addr_t): cache_state_t
    individual cache_data(A: addr_t): data_t

    derived cs_is_u(A: addr_t) = cache_state(A) = cs_ud | cache_state(A) = cs_uc
    derived cs_is_c(A: addr_t) = cache_state(A) = cs_sc | cache_state(A) = cs_uc
    derived cs_is_d(A: addr_t) = cache_state(A) = cs_ud
    derived cs_is_i(A: addr_t) = cache_state(A) = cs_i

    after init {
        cache_state(A) := cs_i;
    }

    instance req_channel: channel_t
    instance data_channel: channel_t
    instance resp_channel: channel_t
    instance snp_channel: channel_t

    instance txns(I: txn_idx_t): txn_slot_t

    action txn_new returns(r: txn_idx_t) = {
        assume r~= txn_idx_null & ~txns(r).in_use;
        txns(r).default;
        txns(r).in_use := true;
    }

    action txn_free (f: txn_idx_t) = {
        assert txns(f).in_use;
        txns(f).in_use := false;
    }

    individual addr_wait_list(A: addr_t): txn_idx_t

    after init {
        addr_wait_list(A) := txn_idx_null;
    }

    derived addr_is_wait(A: addr_t) = addr_wait_list(A) ~= txn_idx_null
    
    action txn_set_wait(addr: addr_t, txn: txn_idx_t) = {
        var ptxn := addr_wait_list(addr);
        if ptxn ~= txn_idx_null {
            txns(ptxn).wake := txn;
        }
        txns(txn).wait := true;
        addr_wait_list(addr) := txn;
    }

    action txns_unset_wait(txn: txn_idx_t) = {
        txns(txn).wait := false;
    }

    action txns_finished(txn: txn_idx_t) = {
        var wake: txn_idx_t := txns(txn).wake;
        assert txns(txn).in_use;
        if wake ~= txn_idx_null {
            assert txns(wake).wait;
            txns_unset_wait(wake);
        } else {
            var addr: addr_t := msg(txns(txn).msg).addr;
            assert addr_wait_list(addr) = txn;
            addr_wait_list(addr) := txn_idx_null;
        }
        txns(txn).in_use := false;
    }


    # action addr_unset_wait(addr: addr_t, txn: txn_idx_t) = {
    #     var ptxn := addr_wait_list(addr);
    #     if ptxn ~= txn_idx_null {
    #         txns(ptxn).has_wake := true;
    #         txns(ptxn).wake := txn;
    #     }
    #     txns(txn).wait := true;
    #     addr_wait_list(addr) := txn;
    # }
}

instance nodes(N: nid_t): node_t

invariant nodes(hn_nid).cs_is_i(A)
invariant nodes(sn_nid).cs_is_i(A)
