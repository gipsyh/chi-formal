#lang ivy1.7

include basic
include message

module txn_slot_t = {
    individual in_use: bool
    individual addr: addr_t
    individual wait: bool
    individual ready: bool
    individual has_wake: bool
    individual wake: idx_t
    individual msg: idx_t

    after init {
        in_use := false;
    }

    action default = {
        wait := false;
        has_wake := false;
    }
}

module channel_t = {
    var head: nat_idx_t
    var tail: nat_idx_t
    individual map(I: nat_idx_t): midx_t

    after init {
        head := 0;
        tail := 0;
    }

    action send returns(res: midx_t) = {
        map(head) := msg_new;
        res := map(head);
        head := head + 1;
    }

    action recv returns (res: midx_t) = {
        assume head > tail;
        res := map(tail);
        tail := tail + 1;
    }
}

module node_t = {
    individual cache_state(A: addr_t): cache_state_t
    individual cache_data(A: addr_t): data_t

    derived cs_is_u(A: addr_t) = cache_state(A) = cs_ud | cache_state(A) = cs_uc
    derived cs_is_c(A: addr_t) = cache_state(A) = cs_sc | cache_state(A) = cs_uc
    derived cs_is_d(A: addr_t) = cache_state(A) = cs_ud
    derived cs_is_i(A: addr_t) = cache_state(A) = cs_i

    after init {
        cache_state(A) := cs_i;
    }

    instance req_channel: channel_t
    instance data_channel: channel_t
    instance resp_channel: channel_t
    instance snp_channel: channel_t

    instance txns(I: txn_idx_t): txn_slot_t

    action txn_new returns(r: txn_idx_t) = {
        assume r~= txn_idx_null & ~txns(r).in_use;
        txns(r).default;
        txns(r).in_use := true;
    }

    action txn_free (f: txn_idx_t) = {
        assert txns(f).in_use;
        txns(f).in_use := false;
    }

    individual addr_wait(A: addr_t): txn_idx_t

    derived addr_is_wait(A: addr_t) = addr_wait(A) ~= txn_idx_null
    
    after init {
        addr_wait(A) := txn_idx_null;
    }
}

instance nodes(N: nid_t): node_t

invariant nodes(hn_nid).cs_is_i(A)
invariant nodes(sn_nid).cs_is_i(A)
