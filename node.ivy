#lang ivy1.7

include basic
include message

module txn_slot_t = {
    individual valid: bool
    individual addr: addr_t
    individual wait: bool
    individual wake: idx_t
    individual msg: idx_t

    after init {
        valid := false;
    }
}

module channel_t(slots) = {
    var head: nat_idx_t
    var tail: nat_idx_t
    individual map(I: nat_idx_t): idx_t

    after init {
        head := 1;
        tail := 1;
    }

    derived is_empty = (head <= tail)

    action send returns(res: idx_t) = {
        map(head) := slots.new;
        res := map(head);
        head := head + 1;
    }

    action recv returns (res: idx_t) = {
        assert ~is_empty;
        res := map(tail);
        tail := tail + 1;
    }
}

module node_t = {
    individual cache_state(A: addr_t): cache_state_t
    individual cache_data(A: addr_t): data_t
    instance txns: slots_t(txn_slot_t)

    derived cs_is_u(A: addr_t) = cache_state(A) = cs_ud | cache_state(A) = cs_uc
    derived cs_is_c(A: addr_t) = cache_state(A) = cs_sc | cache_state(A) = cs_uc
    derived cs_is_d(A: addr_t) = cache_state(A) = cs_ud
    derived cs_is_i(A: addr_t) = cache_state(A) = cs_i

    instance req_channel: channel_t(msg)
    instance data_channel: channel_t(msg)
    instance resp_channel: channel_t(msg)
    instance snp_channel: channel_t(msg)

    after init {
        cache_state(A) := cs_i;
    }
}

instance nodes(N: nid_t): node_t

invariant nodes(hn_nid).cs_is_i(A)
invariant nodes(sn_nid).cs_is_i(A)
