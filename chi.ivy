#lang ivy1.7

include node

individual memory(A: addr_t): data_t

export action rn_req_read_not_share_dirty(rn: nid_t, addr: addr_t) = {
    require is_rn(rn) & nodes(rn).cs_is_i(addr);
    var mid: idx_t := nodes(hn_nid).req_channel.send;
    reqmsg.m(mid).src_id := rn;
    reqmsg.m(mid).tgt_id := hn_nid;
    reqmsg.m(mid).txn_id := nodes(rn).txns.new;
    reqmsg.m(mid).addr := addr;
    reqmsg.m(mid).opcode := req_read_not_share_dirty_t;
    nodes(rn).txns.m(reqmsg.m(mid).txn_id).addr := addr;
}

# export action rn_req_read_unique(rn: nid_t, addr: addr_t) = {
#     require is_rn(rn) & (nodes(rn).cs_is_i(addr) | nodes(rn).cache_state(addr) = cs_sc);
#     var mid: idx_t := nodes(hn_nid).req_channel.push;
#     reqmsg.m(mid).src_id := rn;
#     reqmsg.m(mid).tgt_id := hn_nid;
#     reqmsg.m(mid).txn_id := nodes(rn).txn_slots_fifo.push;
#     reqmsg.m(mid).addr := addr;
#     reqmsg.m(mid).opcode := req_read_unique_t;
#     nodes(rn).txn_slots(reqmsg.m(mid).txn_id).addr := addr;
# }

export action hn_handle_req = {
    require ~nodes(hn_nid).req_channel.is_empty;
    var mid: idx_t := nodes(hn_nid).req_channel.recv;
    if reqmsg.m(mid).opcode = req_read_not_share_dirty_t {
        if some (u_rn: nid_t) is_rn(u_rn) & nodes(u_rn).cs_is_u(reqmsg.m(mid).addr) {
            var smid: idx_t := nodes(u_rn).snp_channel.send;
            snpmsg.m(smid).src_id := hn_nid;
            snpmsg.m(smid).tgt_id := u_rn;
            snpmsg.m(smid).txn_id := nodes(hn_nid).txns.new;
            snpmsg.m(smid).addr := reqmsg.m(mid).addr;
            snpmsg.m(smid).opcode := snp_read_not_share_dirty_fwd_t;
        } else {
            if nodes(hn_nid).cs_is_i(reqmsg.m(mid).addr) {
                var rmid: idx_t := nodes(sn_nid).req_channel.send;
                reqmsg.m(rmid).src_id := hn_nid;
                reqmsg.m(rmid).tgt_id := sn_nid;
                reqmsg.m(rmid).txn_id := nodes(hn_nid).txns.new;
                reqmsg.m(rmid).addr := reqmsg.m(mid).addr;
                reqmsg.m(rmid).opcode := req_read_no_snp_t;
                reqmsg.m(rmid).return_nid := reqmsg.m(mid).src_id;
                reqmsg.m(rmid).return_txn_id := reqmsg.m(mid).txn_id;
            } else {
                assert false;
            }
        }
    } else {
        assert false;
    }
    reqmsg.free(mid);
}

export action sn_handle_req = {
    require ~nodes(sn_nid).req_channel.is_empty;
    var mid: idx_t := nodes(sn_nid).req_channel.recv;
    if reqmsg.m(mid).opcode = req_read_no_snp_t {
        var tgt: nid_t := reqmsg.m(mid).return_nid;
        var dmid: idx_t := nodes(tgt).data_channel.send;
        dmsg.m(dmid).src_id := sn_nid;
        dmsg.m(dmid).tgt_id := tgt;
        dmsg.m(dmid).txn_id := reqmsg.m(mid).return_txn_id;
        dmsg.m(dmid).data := memory(reqmsg.m(mid).addr);
        dmsg.m(dmid).home_nid := reqmsg.m(mid).src_id;
        dmsg.m(dmid).dbid := reqmsg.m(mid).txn_id;
        dmsg.m(dmid).share := false;
    } else {
        assert false;
    }
    reqmsg.free(mid)
}

export action rn_handle_data(rn: nid_t) = {
    require is_rn(rn);
    require ~nodes(rn).data_channel.is_empty;
    var dmid: idx_t := nodes(rn).data_channel.recv;
    var addr: addr_t := nodes(rn).txns.m(dmsg.m(dmid).txn_id).addr;
    nodes(rn).cache_data(addr) := dmsg.m(dmid).data;
    if dmsg.m(dmid).share {
        nodes(rn).cache_state(addr) := cs_sc;
    } else {
        nodes(rn).cache_state(addr) := cs_uc;
    }
    var tgt: nid_t := dmsg.m(dmid).home_nid;
    var rmid: idx_t := nodes(tgt).resp_channel.send;
    respmsg.m(rmid).src_id := rn;
    respmsg.m(rmid).tgt_id := tgt;
    respmsg.m(rmid).txn_id := dmsg.m(dmid).dbid;
    dmsg.free(dmid);
}

export action hn_handle_resp = {
    require ~nodes(hn_nid).resp_channel.is_empty;
    var rmid: idx_t := nodes(hn_nid).resp_channel.recv;
    respmsg.free(rmid);
}

export action rn_handle_snp(rn: nid_t) = {
    require is_rn(rn);
    require ~nodes(rn).snp_channel.is_empty;
    var smid: idx_t := nodes(rn).snp_channel.recv;
    assert nodes(rn).cs_is_u(snpmsg.m(smid).addr);

}

invariant (nodes(X).cs_is_u(A) & nodes(Y).cs_is_u(A)) -> X = Y
# invariant nodes(X).cs_is_c(A) -> (memory(A) = nodes(X).cache_data(A))

attribute method = bmc[10]
# # attribute method = ic
