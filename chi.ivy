#lang ivy1.7

include node

individual memory(A: addr_t): data_t

export action rn_req_read_not_share_dirty(rn: nid_t, addr: addr_t) = {
    require is_rn(rn) & nodes(rn).cs_is_i(addr);
    var mid: idx_t := nodes(hn_nid).req_channel.send;
    reqmsg(mid).src_id := rn;
    reqmsg(mid).tgt_id := hn_nid;
    reqmsg(mid).txn_id := nodes(rn).txns_slots.new;
    reqmsg(mid).addr := addr;
    reqmsg(mid).opcode := req_read_not_share_dirty_t;
    nodes(rn).txns(reqmsg(mid).txn_id).addr := addr;
}

# export action rn_req_read_unique(rn: nid_t, addr: addr_t) = {
#     require is_rn(rn) & (nodes(rn).cs_is_i(addr) | nodes(rn).cache_state(addr) = cs_sc);
#     var mid: idx_t := nodes(hn_nid).req_channel.push;
#     reqmsg(mid).src_id := rn;
#     reqmsg(mid).tgt_id := hn_nid;
#     reqmsg(mid).txn_id := nodes(rn).txn_slots_fifo.push;
#     reqmsg(mid).addr := addr;
#     reqmsg(mid).opcode := req_read_unique_t;
#     nodes(rn).txn_slots(reqmsg(mid).txn_id).addr := addr;
# }

export action hn_handle_req = {
    require ~nodes(hn_nid).req_channel.is_empty;
    var mid: idx_t := nodes(hn_nid).req_channel.recv;
    if reqmsg(mid).opcode = req_read_not_share_dirty_t {
        if some (u_rn: nid_t) is_rn(u_rn) & nodes(u_rn).cs_is_u(reqmsg(mid).addr) {
            var smid: idx_t := nodes(u_rn).snp_channel.send;
            snpmsg(smid).src_id := hn_nid;
            snpmsg(smid).tgt_id := u_rn;
            snpmsg(smid).txn_id := nodes(hn_nid).txns_slots.new;
            snpmsg(smid).addr := reqmsg(mid).addr;
            snpmsg(smid).opcode := snp_read_not_share_dirty_fwd_t;
        } else {
            if nodes(hn_nid).cs_is_i(reqmsg(mid).addr) {
                var rmid: idx_t := nodes(sn_nid).req_channel.send;
                reqmsg(rmid).src_id := hn_nid;
                reqmsg(rmid).tgt_id := sn_nid;
                reqmsg(rmid).txn_id := nodes(hn_nid).txns_slots.new;
                reqmsg(rmid).addr := reqmsg(mid).addr;
                reqmsg(rmid).opcode := req_read_no_snp_t;
                reqmsg(rmid).return_nid := reqmsg(mid).src_id;
                reqmsg(rmid).return_txn_id := reqmsg(mid).txn_id;
            } else {
                assert false;
            }
        }
    } else {
        assert false;
    }
}

export action sn_handle_req = {
    require ~nodes(sn_nid).req_channel.is_empty;
    var mid: idx_t := nodes(sn_nid).req_channel.recv;
    if reqmsg(mid).opcode = req_read_no_snp_t {
        var tgt: nid_t := reqmsg(mid).return_nid;
        var dmid: idx_t := nodes(tgt).data_channel.send;
        dmsg(dmid).src_id := sn_nid;
        dmsg(dmid).tgt_id := tgt;
        dmsg(dmid).txn_id := reqmsg(mid).return_txn_id;
        dmsg(dmid).data := memory(reqmsg(mid).addr);
        dmsg(dmid).home_nid := reqmsg(mid).src_id;
        dmsg(dmid).dbid := reqmsg(mid).txn_id;
        dmsg(dmid).share := false;
    } else {
        assert false;
    }
}

export action rn_handle_data(rn: nid_t) = {
    require is_rn(rn);
    require ~nodes(rn).data_channel.is_empty;
    var dmid: idx_t := nodes(rn).data_channel.recv;
    var addr: addr_t := nodes(rn).txns(dmsg(dmid).txn_id).addr;
    nodes(rn).cache_data(addr) := dmsg(dmid).data;
    if dmsg(dmid).share {
        nodes(rn).cache_state(addr) := cs_sc;
    } else {
        nodes(rn).cache_state(addr) := cs_uc;
    }
    var tgt: nid_t := dmsg(dmid).home_nid;
    var rmid: idx_t := nodes(tgt).resp_channel.send;
    respmsg(rmid).src_id := rn;
    respmsg(rmid).tgt_id := tgt;
    respmsg(rmid).txn_id := dmsg(dmid).dbid;
}

export action hn_handle_resp = {
    require ~nodes(hn_nid).resp_channel.is_empty;
    var rmid: idx_t := nodes(hn_nid).resp_channel.recv;
}

export action rn_handle_snp(rn: nid_t) = {
    require is_rn(rn);
    require ~nodes(rn).snp_channel.is_empty;
    var smid: idx_t := nodes(rn).snp_channel.recv;
    assert nodes(rn).cs_is_u(snpmsg(smid).addr);

}

invariant (nodes(X).cs_is_u(A) & nodes(Y).cs_is_u(A)) -> X = Y
# invariant nodes(X).cs_is_c(A) -> (memory(A) = nodes(X).cache_data(A))

attribute method = bmc[10]
# # attribute method = ic
