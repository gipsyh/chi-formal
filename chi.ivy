#lang ivy1.7

include node

individual memory(A: addr_t): data_t

export action rn_req_read_not_share_dirty(rn: nid_t, addr: addr_t) = {
    require is_rn(rn) & nodes(rn).cs_is_i(addr);
    var mid: midx_t := nodes(hn_nid).req_channel.send;
    msg(mid).src_id := rn;
    msg(mid).tgt_id := hn_nid;
    msg(mid).txn_id := nodes(rn).txn_new;
    msg(mid).addr := addr;
    msg(mid).opcode := req_read_not_share_dirty_t;
    nodes(rn).txns(msg(mid).txn_id).addr := addr;
}

# export action rn_req_read_unique(rn: nid_t, addr: addr_t) = {
#     require is_rn(rn) & (nodes(rn).cs_is_i(addr) | nodes(rn).cache_state(addr) = cs_sc);
#     var mid: midx_t := nodes(hn_nid).req_channel.push;
#     msg(mid).src_id := rn;
#     msg(mid).tgt_id := hn_nid;
#     msg(mid).txn_id := nodes(rn).txn_slots_fifo.push;
#     msg(mid).addr := addr;
#     msg(mid).opcode := req_read_unique_t;
#     nodes(rn).txn_slots(msg(mid).txn_id).addr := addr;
# }

export action hn_handle_req = {
    var mid: midx_t := nodes(hn_nid).req_channel.recv;
    if msg(mid).opcode = req_read_not_share_dirty_t {
        if some (u_rn: nid_t) is_rn(u_rn) & nodes(u_rn).cs_is_u(msg(mid).addr) {
            var smid: midx_t := nodes(u_rn).snp_channel.send;
            msg(smid).src_id := hn_nid;
            msg(smid).tgt_id := u_rn;
            msg(smid).txn_id := nodes(hn_nid).txn_new;
            msg(smid).addr := msg(mid).addr;
            msg(smid).opcode := snp_read_not_share_dirty_fwd_t;
        } else {
            if nodes(hn_nid).cs_is_i(msg(mid).addr) {
                var rmid: midx_t := nodes(sn_nid).req_channel.send;
                msg(rmid).src_id := hn_nid;
                msg(rmid).tgt_id := sn_nid;
                msg(rmid).txn_id := nodes(hn_nid).txn_new;
                msg(rmid).addr := msg(mid).addr;
                msg(rmid).opcode := req_read_no_snp_t;
                msg(rmid).return_nid := msg(mid).src_id;
                msg(rmid).return_txn_id := msg(mid).txn_id;
            } else {
                assert false;
            }
        }
    } else {
        assert false;
    }
    msg_free(mid);
}

export action sn_handle_req = {
    var mid: midx_t := nodes(sn_nid).req_channel.recv;
    if msg(mid).opcode = req_read_no_snp_t {
        var tgt: nid_t := msg(mid).return_nid;
        var dmid: midx_t := nodes(tgt).data_channel.send;
        msg(dmid).src_id := sn_nid;
        msg(dmid).tgt_id := tgt;
        msg(dmid).txn_id := msg(mid).return_txn_id;
        msg(dmid).data := memory(msg(mid).addr);
        msg(dmid).home_nid := msg(mid).src_id;
        msg(dmid).dbid := msg(mid).txn_id;
        msg(dmid).share := false;
    } else {
        assert false;
    }
    msg_free(mid)
}

export action rn_handle_data(rn: nid_t) = {
    require is_rn(rn);
    var dmid: midx_t := nodes(rn).data_channel.recv;
    var addr: addr_t := nodes(rn).txns(msg(dmid).txn_id).addr;
    nodes(rn).cache_data(addr) := msg(dmid).data;
    if msg(dmid).share {
        nodes(rn).cache_state(addr) := cs_sc;
    } else {
        nodes(rn).cache_state(addr) := cs_uc;
    }
    var tgt: nid_t := msg(dmid).home_nid;
    var rspmid: midx_t := nodes(tgt).resp_channel.send;
    msg(rspmid).src_id := rn;
    msg(rspmid).tgt_id := tgt;
    msg(rspmid).txn_id := msg(dmid).dbid;
    msg_free(dmid);
}

export action hn_handle_resp = {
    var rmid: midx_t := nodes(hn_nid).resp_channel.recv;
    msg_free(rmid);
}

export action rn_handle_snp(rn: nid_t) = {
    require is_rn(rn);
    var smid: midx_t := nodes(rn).snp_channel.recv;
    assert nodes(rn).cs_is_u(msg(smid).addr);

}

invariant (nodes(X).cs_is_u(A) & nodes(Y).cs_is_u(A)) -> X = Y
# invariant nodes(X).cs_is_c(A) -> (memory(A) = nodes(X).cache_data(A))

attribute method = bmc[10]
# # attribute method = ic
